bd
as.numeric(td) <- as.Date(strptime(Sys.Date(), "%Y-%m-%d"))
strptime("1983-01-18", "%Y-%m-%d")
bd <- as.Date(strptime("1983-01-18", "%Y-%m-%d"))
bd
td
td <- Sys.Date()
td
bd-td
td <- Sys.Date()
strptime("1983-01-18", "%Y-%m-%d")
bd <- as.Date(strptime("1983-01-18", "%Y-%m-%d"))
bd
td <- Sys.Date()
td
td <- Sys.Date()#
#
bd <- as.Date(strptime("1983-01-18", "%Y-%m-%d"))#
bd-td
td-bd
td <- Sys.Date()#
bd <- as.Date(strptime("1983-01-18", "%Y-%m-%d"))#
td-bd
wdata <- read.csv("/Users/paulczechowski/paul.czechowski@gmail.com/00_work/190117_course_work/190125_STSCI2150/weather_data_Cornell_2018.csv",header=TRUE)
wdata
wdata$TMIN
min(wdata$TMIN)
max(wdata$TMIN)
max(wdata$SNWD)
max(PRCP$)
mean(wdata$SNWD)
mean(wdata$PRCP)
unique(wdata$DATE)
wdata
head(wdata)
mean(wdata$TMIN)
unique(wdata$DATE)
mean(wdata$TMIN)
mean(wdata$TMAX)
max(wdata$TMAX) # (degrees Fahrenheit)
wdata$TMIN
wdata$TMAX - wdata$TMIN
min(wdata$TMAX - wdata$TMIN)#
max(wdata$TMAX - wdata$TMIN)#
mean(wdata$TMAX - wdata$TMIN)
soda <- read.csv("/Users/paulczechowski/paul.czechowski@gmail.com/00_work/190117_course_work/190125_STSCI2150/First_Class_Poll_S19.csv",header=TRUE)#
head(soda)
max(soda)
max(soda$soda)
soda$soda
median(soda$height)
head(soda)
max(soda$siblings)
mean(soda$distance)
summary(heartrate)
summary(soda$heartrate)
install.packages(ggmap)
install.packages("ggmap")
library(ggmap)
arena_dist <- mapdist(from = "Leipzig, Germany ", to = "Ithaca, NY")
arena_dist <- mapdist(from = "Leipzig", to = "Ithaca, NY")
mapdist(from = "Leipzig", to = "Ithaca New York")
wd
wd()
getwf()
getwd()
tmp <- installed.packages()#
installedpkgs <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])#
save(installedpkgs, file="installed_old.rda")
ls()
tmp <- installed.packages()
installedpkgs.new <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])
missing <- setdiff(installedpkgs, installedpkgs.new)
missing <- setdiff(tmp, installedpkgs.new)
missing
install.packages(missing)
update.packages()
chooseBioCmirror()#
biocLite() #
load("installed_old.rda")#
tmp <- installed.packages()#
installedpkgs.new <- as.vector(tmp[is.na(tmp[,"Priority"]), 1])#
missing <- setdiff(installedpkgs, installedpkgs.new)#
for (i in 1:length(missing)) biocLite(missing[i])
biocLite()
bioclite()
if (!requireNamespace("BiocManager"))#
    install.packages("BiocManager")#
BiocManager::install()
BiocManager::valid()
update.packages()
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 21, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paul/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paul/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: Voyages#
#'#
#' This data is only available for ports in between which voyages exist.#
#' (Risk Formula is currently `(log(src_heap$ROUT$TRIPS) + 1) * (1 / src_heap$ROUT$EDST)`#
#' as defined in `500_30_shape_matrices.R`. Using voyages only for now)
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 21, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paul/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: Voyages#
#'#
#' This data is only available for ports in between which voyages exist.#
#' (Risk Formula is currently `(log(src_heap$ROUT$TRIPS) + 1) * (1 / src_heap$ROUT$EDST)`#
#' as defined in `500_30_shape_matrices.R`. Using voyages only for now)#
#
# loading matrix with trips (not risks), not loading "/Users/paul/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_risks_full.Rdata"#
load("/Users/paul/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output_mat_trips_full.Rdata")
# loading matrix with trips (not risks), not loading "/Users/paul/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_risks_full.Rdata"#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output_mat_trips_full.Rdata")
q()
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 21, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: Voyages#
#'#
#' This data is only available for ports in between which voyages exist.#
#' (Risk Formula is currently `(log(src_heap$ROUT$TRIPS) + 1) * (1 / src_heap$ROUT$EDST)`#
#' as defined in `500_30_shape_matrices.R`. Using voyages only for now)#
#
# loading matrix with trips (not risks), not loading "/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_risks_full.Rdata"#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output_mat_trips_full.Rdata")
install.packages("ggplot2", "ggbiplot", "tidyverse", "gdata")
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS
library ("ggplot2")   # for ggCaterpillar
purge ("ggplot2")
unistall ("ggplot")
uninstall.packages(library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan"))
uninstall.packages("ggplot2","ggbiplot","gdata","tidyverse","reshape2","lme4","vegan")
remove.packages("ggplot2","ggbiplot","gdata","tidyverse","reshape2","lme4","vegan")
remove.packages(c("ggplot2","ggbiplot","gdata","tidyverse","reshape2","lme4","vegan"))
rinstall.packages(c("ggplot2","ggbiplot","gdata","tidyverse","reshape2","lme4","vegan"))
install.packages(c("ggplot2","ggbiplot","gdata","tidyverse","reshape2","lme4","vegan"))
q()
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output_mat_trips_full.Rdata")
mat_trips[35:50, 35:50]
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")
mat_env_dist_full[35:50, 35:50]
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Eukaryotes_core_metrics/unweighted_unifrac_distance_matrix/distance-matrix.tsv"
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)
resp_mat
resp_mat[35:50, 35:50]
resp_mat[01:10, 01:10]
class(resp_mat)
#' # Data formatting #
#' #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#' Need to be done before the predictors: Matrix fields need to be averaged (09-Apr-2019: using median)#
#' across replicates. The resulting ports descriptors are then used to shape#
#' predictor data. **NOT** Inverting Unifrac distances to closeness in order to match #
#' `(1 / src_heap$ROUT$EDST)`, which also is a measure of closeness.#
#
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL
any(colnames(resp_mat) == rownames(resp_mat))
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__collapsed_matrix.csv")
dim(mat_trips)#
mat_trips <- mat_trips[rowSums(is.na(mat_trips))!=ncol(mat_trips), colSums(is.na(mat_trips))!=nrow(mat_trips) ]#
dim(mat_trips) #
#
# quick and dirty - manual lookup for subsetting#
#   improve this. Manual lookup via:#
#   `open  -a "Microsoft Excel" "/Users/paul/Dropbox/NSF NIS-WRAPS Data/raw data for Mandana/PlacesFile_updated_Aug2017.xlsx"`#
colnames(r_mat_clpsd)#
#
# also see `/Users/paulczechowski/Documents/CU_combined/Github/500_30_shape_matrices.R`#
# test 08.04.2019 - AD AW BA BT CB CH HN HS HT LB MI #
#                   NA NO OK PH PL PM RC RT SW SY VN#
##
# "3110" "576"  "2729" "854" "2141" "2907" "2503" "3367" "2331" "7597" "4899"#
# "3108"  "3381" "7598" "2503" "234" "193" "4777" "1165" "1165" "311" #
##
#   use order  of response matrix (!!!) 09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
#
#   use order  of response matrix (!!!) 09-April-2019 ("BA" and "HN" missing after subsampling)#
# #
#        PH SW SY AD CH BT #
#        HN HT LB MI AW BA#
#        CB NA NO OK PL PM#
#        RC RT VN GH WL ZB
r_mat_clpsd
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)
r_mat_clpsd[,"HS"]
r_mat_clpsd
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)
r_mat_clpsd
r_mat_clpsd <- fill_collapsed_responses_matrix(r_mat_clpsd, resp_mat)
r_mat_clpsd
r_mat_clpsd[,"HS"]
r_mat_clpsd["HS", ]
r_mat_clpsd[,"HS"] <- NULL
r_mat_clpsd[,-"HS"]
r_mat_clpsd[,-c("HS")]
r_mat_clpsd
r_mat_clpsd[, colnames(r_mat_clpsd) != "HS"]
r_mat_clpsd[rownames(r_mat_clpsd) != "HS", ]
r_mat_clpsd <- r_mat_clpsd[, colnames(r_mat_clpsd) != "HS"]
r_mat_clpsd <- r_mat_clpsd[rownames(r_mat_clpsd) != "HS", ]
r_mat_clpsd
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__collapsed_matrix.csv")
dim(r_mat_clpsd)
dim(mat_trips)#
mat_trips <- mat_trips[rowSums(is.na(mat_trips))!=ncol(mat_trips), colSums(is.na(mat_trips))!=nrow(mat_trips) ]#
dim(mat_trips)
colnames(r_mat_clpsd)
head(mat_trips)
mat_trips <- mat_trips[c("2503", "1165", "1165", "3110",        "854",#
                         "2503", "2331", "7597", "4899", "576", "2729",#
                         "2141", "3108", "3381", "7598", "238",  "193",#
                         "4777",  "830",  "311", "4538", "7975", "1675"), #
                       c("2503", "1165", "1165", "3110",         "854",#
                         "2503", "2331", "7597", "4899", "576", "2729",#
                         "2141", "3108", "3381", "7598", "238",  "193",#
                         "4777",  "830",  "311", "4538", "7975", "1675")]
mat_trips[lower.tri(mat_trips, diag = FALSE)] <- NA
# predictors - copy names - make automatic !! #
colnames(mat_trips) <- colnames(r_mat_clpsd)#
rownames(mat_trips) <- rownames(r_mat_clpsd)
#' Finished matrix - Trips. Needs to be used to filter all other matrices#
#' (Other predictors and responses) to the same non-`NA` before analysis.#
mat_trips
mat_env_dist <- mat_env_dist_full[c("2503", "1165", "1165", "3110",         "854",#
                                    "2503", "2331", "7597", "4899", "576", "2729",#
                                    "2141", "3108", "3381", "7598", "238",  "193",#
                                    "4777",  "830",  "311", "4538", "7975", "1675"), #
                                  c("2503", "1165", "1165", "3110",         "854",#
                                    "2503", "2331", "7597", "4899", "576", "2729",#
                                     "2141", "3108", "3381", "7598", "238",  "193",#
                                    "4777",  "830",  "311", "4538", "7975", "1675")]
mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "FON Approach: Response of UNIFRAC values to Predictors (in SD)")
plot_model
library("sjPlot")
install.packages("sjPlot")
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "FON Approach: Response of UNIFRAC values to Predictors (in SD)")
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,
type = "std", #
   title = "FON Approach: Response of UNIFRAC values to Predictors (in SD)")
library("sjPlot")
install.packages('TMB', type = 'source')
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "FON Approach: Response of UNIFRAC values to Predictors (in SD)")
vars_model_full
summary(vars_model_full)
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "FON Approach: Response of UNIFRAC values to Predictors (in SD)")#
#
#' Residuals#
plot(vars_model_full)#
#
## check normality of the residuals#
qqnorm(residuals(vars_model_full))#
#
## plotting random effects - trial after https://stackoverflow.com/questions/13847936/in-r-plotting-random-effects-from-lmer-lme4-package-using-qqmath-or-dotplot#
# qqplot of the random effects with their variances#
# "The last line of code produces a really nice plot of each intercept with the error around each estimate."#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$PORT#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$DEST#
#' ### Leverage of Observations#
#
## model is not influenced by one or a small set of observations ?#
ggplot(data.frame(lev=hatvalues(vars_model_full),pearson=residuals(vars_model_full, type="pearson")),#
      aes(x=lev,y=pearson)) + geom_point() + theme_bw()#
#
#' ## Null Model and checking #
#
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
summary(vars_model_null)#
#
#' ## Model Significance#
anova(vars_model_null, vars_model_full)
summary(vars_model_null)
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars, REML=FALSE)
vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars, REML=FALSE)
vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars)
vars_model_full
summary(vars_model_full)
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)
vars_model_full
summary(vars_model_full)
vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars)
vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF, data=vars)
vars_model_null <- lm(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF, data=vars)
summary(vars_model_null)
anova(vars_model_null, vars_model_full)
vars_model_full
vars_model_null <- lm(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF, data=vars)
anova(vars_model_null, vars_model_full)
vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars)
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level
vars_model_null <- lm(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF, data=vars)
vars_model_null
summary(vars_model_null)
anova(vars_model_null, vars_model_full)
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)
anova(vars_model_null, vars_model_full)
rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 21, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: Voyages#
#'#
#' This data is only available for ports in between which voyages exist.#
#' (Risk Formula is currently `(log(src_heap$ROUT$TRIPS) + 1) * (1 / src_heap$ROUT$EDST)`#
#' as defined in `500_30_shape_matrices.R`. Using voyages only for now)#
#
# loading matrix with trips (not risks), not loading "/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_risks_full.Rdata"#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output_mat_trips_full.Rdata")#
#
# checking - see debugging notes: row- and colnames are undefined#
mat_trips[35:50, 35:50]#
#
#' ## Predictors 2 of 2: Environmental Distances#
#'#
#' This data is available for many ports (more ports then shipping routes)#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")#
#
# checking - see debugging notes: some port numbers in row-/colnames are not unique#
#          - see debugging notes: row- and colnames are undefined, bu seemingly consitent with above#
#             so likley less problematic#
mat_env_dist_full[35:50, 35:50]#
#
#'#
#' <!-- -------------------------------------------------------------------- -->#
#'      #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#
# this path should match the parameter combination of the Euler script (which isn't used anymore) <-- continue here#
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Eukaryotes_core_metrics/unweighted_unifrac_distance_matrix/distance-matrix.tsv"#
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)#
#
# checking import and format#
resp_mat[35:50, 35:50]#
resp_mat[01:10, 01:10]#
class(resp_mat)#
#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data formatting #
#' #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#' Need to be done before the predictors: Matrix fields need to be averaged (09-Apr-2019: using median)#
#' across replicates. The resulting ports descriptors are then used to shape#
#' predictor data. **NOT** Inverting Unifrac distances to closeness in order to match #
#' `(1 / src_heap$ROUT$EDST)`, which also is a measure of closeness.#
#
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL#
#
# check data frame row and column formatting - better to have them equal #
any(colnames(resp_mat) == rownames(resp_mat))#
#
# Create empty receiving matrix from data frame ...#
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)#
#
# Collapsed matrix should receive data for samples: #
# PH SW SY AD    BT HN HT LB MI AW BA CB HS NA NO OK PL PM RC RT VN GH WL ZB .#
#
# These are from old data #
# PH SW SY AD CH BT HN HT LB MI AW BA CB    NA NO OK PL PM RC RT VN GH WL ZB#
# PH SW SY AD CH BT HN HT LB MI AW BA CB    NA NO OK PL PM RC RT VN GH WL ZB#
# ... and fill empty receiving matrix. #
#
r_mat_clpsd <- fill_collapsed_responses_matrix(r_mat_clpsd, resp_mat)#
#
##### erase HS and CH ##### #
r_mat_clpsd <- r_mat_clpsd[, colnames(r_mat_clpsd) != "HS"]#
r_mat_clpsd <- r_mat_clpsd[rownames(r_mat_clpsd) != "HS", ]#
#
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__collapsed_matrix.csv")#
dim(r_mat_clpsd)#
#'#
#' <!-- -------------------------------------------------------------------- -->#
#'      #
#' ## Predictors 1 of 2: Voyages#
#'#
#
# to save memory: discard completely undefined rows and columns (shrinks from#
#  6651 * 6651 to 2332 * 2332#
dim(mat_trips)#
mat_trips <- mat_trips[rowSums(is.na(mat_trips))!=ncol(mat_trips), colSums(is.na(mat_trips))!=nrow(mat_trips) ]#
dim(mat_trips) #
#
# quick and dirty - manual lookup for subsetting#
#   improve this. Manual lookup via:#
#   `open  -a "Microsoft Excel" "/Users/paul/Dropbox/NSF NIS-WRAPS Data/raw data for Mandana/PlacesFile_updated_Aug2017.xlsx"`#
colnames(r_mat_clpsd)#
#
# also see `/Users/paulczechowski/Documents/CU_combined/Github/500_30_shape_matrices.R`#
# test 08.04.2019 - AD AW BA BT CB CH HN HS HT LB MI #
#                   NA NO OK PH PL PM RC RT SW SY VN#
##
# "3110" "576"  "2729" "854" "2141" "2907" "2503" "3367" "2331" "7597" "4899"#
# "3108"  "3381" "7598" "2503" "234" "193" "4777" "1165" "1165" "311" #
##
#   use order  of response matrix (!!!) 09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
#
#   use order  of response matrix (!!!) 09-April-2019 ("BA" and "HN" missing after subsampling)#
# #
#        PH SW SY AD    BT #
#        HN HT LB MI AW BA#
#        CB NA NO OK PL PM#
#        RC RT VN GH WL ZB#
#
head(mat_trips)#
mat_trips <- mat_trips[c("2503", "1165", "1165", "3110",        "854",#
                         "2503", "2331", "7597", "4899", "576", "2729",#
                         "2141", "3108", "3381", "7598", "238",  "193",#
                         "4777",  "830",  "311", "4538", "7975", "1675"), #
                       c("2503", "1165", "1165", "3110",         "854",#
                         "2503", "2331", "7597", "4899", "576", "2729",#
                         "2141", "3108", "3381", "7598", "238",  "193",#
                         "4777",  "830",  "311", "4538", "7975", "1675")]#
#
# Keep lower triangle#
mat_trips[lower.tri(mat_trips, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_trips) <- colnames(r_mat_clpsd)#
rownames(mat_trips) <- rownames(r_mat_clpsd)#
#
#' Finished matrix - Trips. Needs to be used to filter all other matrices#
#' (Other predictors and responses) to the same non-`NA` before analysis.#
mat_trips#
#
#'#
#' ## Predictors 2 of 2: Environmental distances#
#'#
# quick and dirty - manual lookup#
#   use order  of response matrix (!!!)#
#   here "PH","SP","AD","CH", "BT", "HN", "HT", "LB", "MI"#
#   improve (!!!) this. Manual lookup via:#
#   `open /Users/paul/Dropbox/NSF\ NIS-WRAPS\ Data/raw\ data\ for\ Mandana/PlacesFile_updated_Aug2017.xlsx -a "Microsoft Excel"`#
#
mat_env_dist <- mat_env_dist_full[c("2503", "1165", "1165", "3110",         "854",#
                                    "2503", "2331", "7597", "4899", "576", "2729",#
                                    "2141", "3108", "3381", "7598", "238",  "193",#
                                    "4777",  "830",  "311", "4538", "7975", "1675"), #
                                  c("2503", "1165", "1165", "3110",         "854",#
                                    "2503", "2331", "7597", "4899", "576", "2729",#
                                     "2141", "3108", "3381", "7598", "238",  "193",#
                                    "4777",  "830",  "311", "4538", "7975", "1675")]#
#
mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)#
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist#
#
#'#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' ## Getting Dataframes for modelling #
#'#
#
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")#
#
# Checking response and predictor variable distributions#
#
## Responses#
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are tiny#
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)#
#'#
#' <!-- #################################################################### -->#
#'#
#' <!-- #################################################################### -->#
#'#
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
# vars_model_full <- lm(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF, data=vars)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "FON Approach: Response of eukaryotic UNIFRAC values to Predictors (in SD)")
anova(vars_model_null, vars_model_full)
#' Residuals#
plot(vars_model_full)#
#
## check normality of the residuals#
qqnorm(residuals(vars_model_full))#
#
## plotting random effects - trial after https://stackoverflow.com/questions/13847936/in-r-plotting-random-effects-from-lmer-lme4-package-using-qqmath-or-dotplot#
# qqplot of the random effects with their variances#
# "The last line of code produces a really nice plot of each intercept with the error around each estimate."#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$PORT#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$DEST#
#' ### Leverage of Observations#
#
## model is not influenced by one or a small set of observations ?#
ggplot(data.frame(lev=hatvalues(vars_model_full),pearson=residuals(vars_model_full, type="pearson")),#
      aes(x=lev,y=pearson)) + geom_point() + theme_bw()#
#
#' ## Null Model and checking #
#
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
# vars_model_null <- lm(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF, data=vars)#
#' ### Model Summary#
summary(vars_model_null)#
#
#' ## Model Significance#
anova(vars_model_null, vars_model_full)
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 20, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#' Bolting in ob 20.05.2019 - Importing mandans HON data#
mat_trips_hon<-read.csv("/Users/paulczechowski/Box Sync/CU_NIS-WRAPS/190208_hon_data/hon_matrix.csv", sep=",", row.names=1)#
mat_trips_hon <- as.matrix(mat_trips_hon)#
#
#' ## Predictors 2 of 2: Environmental Distances#
#'#
#' This data is available for many ports (more ports then shipping routes)#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")#
#
# checking - see debugging notes: some port numbers in row-/colnames are not unique#
#          - see debugging notes: row- and colnames are undefined, bu seemingly consitent with above#
#             so likley less problematic#
mat_env_dist_full[35:50, 35:50]#
#'      #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#
# this path should match the parameter combination of the Euler script (which isn't used anymore) <-- continue here#
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Metazoans_core_metrics/190520_unweighted_unifrac_distance_matrix.qza/distance-matrix.tsv"#
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)#
#
# checking import and format#
resp_mat[35:50, 35:50]#
resp_mat[01:10, 01:10]#
class(resp_mat)#
#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data formatting #
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#
colnames(mat_trips_hon) <- c("ZB", "GH", "AW", "RT", "BT", "SW",#
                             "HT", "NO", "WL", "OK", "MI", "LB",#
                             "HN", "VN", "BA", "AD", "RC", "NA",#
                             "CB")#
rownames(mat_trips_hon) <- c("AD", "AW", "BT", "BA", "CB", "GH",#
                             "HN", "HT", "LB", "MI", "NA", "NO",#
                             "OK", "PL", "PM", "RC", "RT", "SW",#
                             "VN", "WL", "ZB")#
#
# order names alphabetically - for sanity reasons#
mat_trips_hon <- mat_trips_hon[,order(colnames(mat_trips_hon))]#
mat_trips_hon <- mat_trips_hon[order(rownames(mat_trips_hon)), ]#
# need symmetrical matrix, discarding some values#
mat_trips_hon <- mat_trips_hon[colnames(mat_trips_hon), ]#
dim(mat_trips_hon)#
#
mat_trips <- mat_trips_hon#
#
# setting port numbers#
# colnames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")#
# rownames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "238", "193", "4777", "830", "1165", "311", "7975", "1675")#
# #
# #
# mat_trips <- mat_trips_hon [c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675"), #
#                             c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675")]#
#
# Keep lower triangle#
# mat_trips[lower.tri(mat_trips, diag = FALSE)] <- NA#
# #
# predictors - copy names - make automatic !! #
# colnames(mat_trips) <- colnames(r_mat_clpsd)#
# rownames(mat_trips) <- rownames(r_mat_clpsd)#
# #
# ' Finished matrix - Trips. Needs to be used to filter all other matrices#
# ' (Other predictors and responses) to the same non-`NA` before analysis.#
# mat_trips#
#
#' #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#' Need to be done before the predictors: Matrix fields need to be averaged (09-Apr-2019: using median)#
#' across replicates. The resulting ports descriptors are then used to shape#
#' predictor data. **NOT** Inverting Unifrac distances to closeness in order to match #
#' `(1 / src_heap$ROUT$EDST)`, which also is a measure of closeness.#
#
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL#
#
# check data frame row and column formatting - better to have them equal #
any(colnames(resp_mat) == rownames(resp_mat))#
#
# Create empty receiving matrix from data frame ...#
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)#
#
# ... and fill empty receiving matrix. #
r_mat_clpsd <- fill_collapsed_responses_matrix_full(r_mat_clpsd, resp_mat)#
#
# for possible subsetting #
colnames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
rownames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
r_mat_clpsd <- r_mat_clpsd[colnames(mat_trips_hon), ]#
r_mat_clpsd <- r_mat_clpsd[, colnames(mat_trips_hon)]#
#
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/510_85_hon_model_1__output__collapsed_matrix_full.csv")#
#
#'#
#' ## Predictors 2 of 2: Environmental distances#
#'#
# quick and dirty - manual lookup#
#   use order  of response matrix (!!!)#
#   here "PH","SP","AD","CH", "BT", "HN", "HT", "LB", "MI"#
#   improve (!!!) this. Manual lookup via:#
#   `open /Users/paulczechowski/Dropbox/NSF\ NIS-WRAPS\ Data/raw\ data\ for\ Mandana/PlacesFile_updated_Aug2017.xlsx -a "Microsoft Excel"`#
#
mat_env_dist <- mat_env_dist_full[c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675"), #
                                  c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")] #
#
# mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)#
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist#
#
#'#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' ## Getting Dataframes for modelling #
#'#
#
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data_raw[model_data_raw == 0] <- NA#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")#
#
# Checking response and predictor variable distributions#
#
## Responses#
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are tiny#
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)#
#'#
#' <!-- #################################################################### -->#
#'#
#' <!-- #################################################################### -->#
#'#
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")#
#
#' Residuals#
plot(vars_model_full)#
#
## check normality of the residuals#
qqnorm(residuals(vars_model_full))#
#
## plotting random effects - trial after https://stackoverflow.com/questions/13847936/in-r-plotting-random-effects-from-lmer-lme4-package-using-qqmath-or-dotplot#
# qqplot of the random effects with their variances#
# "The last line of code produces a really nice plot of each intercept with the error around each estimate."#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$PORT#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$DEST#
#' ### Leverage of Observations#
#
## model is not influenced by one or a small set of observations ?#
ggplot(data.frame(lev=hatvalues(vars_model_full),pearson=residuals(vars_model_full, type="pearson")),#
      aes(x=lev,y=pearson)) + geom_point() + theme_bw()#
#
#' ## Null Model and checking #
#
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
summary(vars_model_null)#
#
#' ## Model Significance#
anova(vars_model_null, vars_model_full)#
#
#' <!-- #################################################################### -->#
#'#
#' # Session info#
#'#
#' The code and output in this document were tested and generated in the#
#' following computing environment:#
#+ echo=FALSE#
sessionInfo()#
#
#' # References
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 20, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#' Bolting in ob 20.05.2019 - Importing mandans HON data#
mat_trips_hon<-read.csv("/Users/paulczechowski/Box Sync/CU_NIS-WRAPS/190208_hon_data/hon_matrix.csv", sep=",", row.names=1)#
mat_trips_hon <- as.matrix(mat_trips_hon)#
#
#' ## Predictors 2 of 2: Environmental Distances#
#'#
#' This data is available for many ports (more ports then shipping routes)#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")#
#
# checking - see debugging notes: some port numbers in row-/colnames are not unique#
#          - see debugging notes: row- and colnames are undefined, bu seemingly consitent with above#
#             so likley less problematic#
mat_env_dist_full[35:50, 35:50]#
#'      #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#
# this path should match the parameter combination of the Euler script (which isn't used anymore) <-- continue here#
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Eukaryotes_core_metrics/unweighted_unifrac_distance_matrix/distance-matrix.tsv"#
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)#
#
# checking import and format#
resp_mat[35:50, 35:50]#
resp_mat[01:10, 01:10]#
class(resp_mat)
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data formatting #
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#
colnames(mat_trips_hon) <- c("ZB", "GH", "AW", "RT", "BT", "SW",#
                             "HT", "NO", "WL", "OK", "MI", "LB",#
                             "HN", "VN", "BA", "AD", "RC", "NA",#
                             "CB")#
rownames(mat_trips_hon) <- c("AD", "AW", "BT", "BA", "CB", "GH",#
                             "HN", "HT", "LB", "MI", "NA", "NO",#
                             "OK", "PL", "PM", "RC", "RT", "SW",#
                             "VN", "WL", "ZB")#
#
# order names alphabetically - for sanity reasons#
mat_trips_hon <- mat_trips_hon[,order(colnames(mat_trips_hon))]#
mat_trips_hon <- mat_trips_hon[order(rownames(mat_trips_hon)), ]#
# need symmetrical matrix, discarding some values#
mat_trips_hon <- mat_trips_hon[colnames(mat_trips_hon), ]#
dim(mat_trips_hon)#
#
mat_trips <- mat_trips_hon
mat_trips
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL#
#
# check data frame row and column formatting - better to have them equal #
any(colnames(resp_mat) == rownames(resp_mat))#
#
# Create empty receiving matrix from data frame ...#
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)
r_mat_clpsd <- fill_collapsed_responses_matrix_full(r_mat_clpsd, resp_mat)#
#
# for possible subsetting #
colnames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
rownames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"
r_mat_clpsd <- r_mat_clpsd[colnames(mat_trips_hon), ]
r_mat_clpsd <- r_mat_clpsd[, colnames(mat_trips_hon)]
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/510_85_hon_model_1__output__collapsed_matrix_full.csv")#
#
#'#
#' ## Predictors 2 of 2: Environmental distances#
#'#
# quick and dirty - manual lookup#
#   use order  of response matrix (!!!)#
#   here "PH","SP","AD","CH", "BT", "HN", "HT", "LB", "MI"#
#   improve (!!!) this. Manual lookup via:#
#   `open /Users/paulczechowski/Dropbox/NSF\ NIS-WRAPS\ Data/raw\ data\ for\ Mandana/PlacesFile_updated_Aug2017.xlsx -a "Microsoft Excel"`
r_mat_clpsd
mat_env_dist <- mat_env_dist_full[c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675"), #
                                  c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")] #
#
# mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)#
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist#
#
#'#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' ## Getting Dataframes for modelling #
#'#
#
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data_raw[model_data_raw == 0] <- NA#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")#
#
# Checking response and predictor variable distributions#
#
## Responses#
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are tiny#
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)#
#'#
#' <!-- #################################################################### -->#
#'#
#' <!-- #################################################################### -->#
#'#
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")
install.packages("snakecase")
require("snakecase")
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 20, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#' Bolting in ob 20.05.2019 - Importing mandans HON data#
mat_trips_hon<-read.csv("/Users/paulczechowski/Box Sync/CU_NIS-WRAPS/190208_hon_data/hon_matrix.csv", sep=",", row.names=1)#
mat_trips_hon <- as.matrix(mat_trips_hon)#
#
#' ## Predictors 2 of 2: Environmental Distances#
#'#
#' This data is available for many ports (more ports then shipping routes)#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")#
#
# checking - see debugging notes: some port numbers in row-/colnames are not unique#
#          - see debugging notes: row- and colnames are undefined, bu seemingly consitent with above#
#             so likley less problematic#
mat_env_dist_full[35:50, 35:50]#
#'      #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#
# this path should match the parameter combination of the Euler script (which isn't used anymore) <-- continue here#
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Eukaryotes_core_metrics/unweighted_unifrac_distance_matrix/distance-matrix.tsv"#
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)#
#
# checking import and format#
resp_mat[35:50, 35:50]#
resp_mat[01:10, 01:10]#
class(resp_mat)#
#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data formatting #
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#
colnames(mat_trips_hon) <- c("ZB", "GH", "AW", "RT", "BT", "SW",#
                             "HT", "NO", "WL", "OK", "MI", "LB",#
                             "HN", "VN", "BA", "AD", "RC", "NA",#
                             "CB")#
rownames(mat_trips_hon) <- c("AD", "AW", "BT", "BA", "CB", "GH",#
                             "HN", "HT", "LB", "MI", "NA", "NO",#
                             "OK", "PL", "PM", "RC", "RT", "SW",#
                             "VN", "WL", "ZB")#
#
# order names alphabetically - for sanity reasons#
mat_trips_hon <- mat_trips_hon[,order(colnames(mat_trips_hon))]#
mat_trips_hon <- mat_trips_hon[order(rownames(mat_trips_hon)), ]#
# need symmetrical matrix, discarding some values#
mat_trips_hon <- mat_trips_hon[colnames(mat_trips_hon), ]#
dim(mat_trips_hon)#
#
mat_trips <- mat_trips_hon#
#
# setting port numbers#
# colnames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")#
# rownames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "238", "193", "4777", "830", "1165", "311", "7975", "1675")#
# #
# #
# mat_trips <- mat_trips_hon [c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675"), #
#                             c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675")]#
#
# Keep lower triangle#
# mat_trips[lower.tri(mat_trips, diag = FALSE)] <- NA#
# #
# predictors - copy names - make automatic !! #
# colnames(mat_trips) <- colnames(r_mat_clpsd)#
# rownames(mat_trips) <- rownames(r_mat_clpsd)#
# #
# ' Finished matrix - Trips. Needs to be used to filter all other matrices#
# ' (Other predictors and responses) to the same non-`NA` before analysis.#
# mat_trips#
#
#' #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#' Need to be done before the predictors: Matrix fields need to be averaged (09-Apr-2019: using median)#
#' across replicates. The resulting ports descriptors are then used to shape#
#' predictor data. **NOT** Inverting Unifrac distances to closeness in order to match #
#' `(1 / src_heap$ROUT$EDST)`, which also is a measure of closeness.#
#
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL#
#
# check data frame row and column formatting - better to have them equal #
any(colnames(resp_mat) == rownames(resp_mat))#
#
# Create empty receiving matrix from data frame ...#
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)#
#
# ... and fill empty receiving matrix. #
r_mat_clpsd <- fill_collapsed_responses_matrix_full(r_mat_clpsd, resp_mat)#
#
# for possible subsetting #
colnames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
rownames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
r_mat_clpsd <- r_mat_clpsd[colnames(mat_trips_hon), ]#
r_mat_clpsd <- r_mat_clpsd[, colnames(mat_trips_hon)]#
#
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/510_85_hon_model_1__output__collapsed_matrix_full.csv")#
#
#'#
#' ## Predictors 2 of 2: Environmental distances#
#'#
# quick and dirty - manual lookup#
#   use order  of response matrix (!!!)#
#   here "PH","SP","AD","CH", "BT", "HN", "HT", "LB", "MI"#
#   improve (!!!) this. Manual lookup via:#
#   `open /Users/paulczechowski/Dropbox/NSF\ NIS-WRAPS\ Data/raw\ data\ for\ Mandana/PlacesFile_updated_Aug2017.xlsx -a "Microsoft Excel"`#
#
mat_env_dist <- mat_env_dist_full[c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675"), #
                                  c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")] #
#
# mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)#
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist#
#
#'#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' ## Getting Dataframes for modelling #
#'#
#
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data_raw[model_data_raw == 0] <- NA#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")#
#
# Checking response and predictor variable distributions#
#
## Responses#
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are tiny#
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)#
#'#
#' <!-- #################################################################### -->#
#'#
#' <!-- #################################################################### -->#
#'#
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_TRIPS + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")#
#
#' Residuals#
plot(vars_model_full)#
#
## check normality of the residuals#
qqnorm(residuals(vars_model_full))#
#
## plotting random effects - trial after https://stackoverflow.com/questions/13847936/in-r-plotting-random-effects-from-lmer-lme4-package-using-qqmath-or-dotplot#
# qqplot of the random effects with their variances#
# "The last line of code produces a really nice plot of each intercept with the error around each estimate."#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$PORT#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$DEST#
#' ### Leverage of Observations#
#
## model is not influenced by one or a small set of observations ?#
ggplot(data.frame(lev=hatvalues(vars_model_full),pearson=residuals(vars_model_full, type="pearson")),#
      aes(x=lev,y=pearson)) + geom_point() + theme_bw()#
#
#' ## Null Model and checking #
#
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
summary(vars_model_null)#
#
#' ## Model Significance#
anova(vars_model_null, vars_model_full)#
#
#' <!-- #################################################################### -->#
#'#
#' # Session info#
#'#
#' The code and output in this document were tested and generated in the#
#' following computing environment:#
#+ echo=FALSE#
sessionInfo()#
#
#' # References
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")
#' ---#
#' title: "Compare Response and Predictor Matrices using Mixed Effect Models"#
#' author: "Paul Czechowski"#
#' date: "May 20, 2019"#
#' output: pdf_document#
#' toc: true#
#' highlight: zenburn#
#' bibliography: ./references.bib#
#' ---#
#' #
#' This script version tests the influence of environmental data and #
#' the influence of voyages against biological responses. This script#
#' only considers port in between which routes are present, such ports are#
#' fewer the ports which have environmental distances available. (All ports #
#' with measurements have environmental distances available.)#
#'#
#' This code commentary is included in the R code itself and can be rendered at#
#' any stage using `rmarkdown::render ("/Users/paulczechowski/Documents/CU_combined/Github/505_80_mixed_effect_model.R")`.#
#' Please check the session info at the end of the document for further #
#' notes on the coding environment.#
#' #
#' # Environment preparation#
#
# empty buffer#
# ============#
rm(list=ls())#
#
# load packages#
# =============#
library ("ggplot2")   # for ggCaterpillar#
library ("ggbiplot")  # better PCoA plotting, get via `library(devtools); install_github("vqv/ggbiplot")`#
                      # uses `plyr` and needs to be loaded before `dplyr` in `tidyverse` #
library ("gdata")     # matrix functions#
library ("tidyverse") # dplyr and friends#
library ("reshape2")  # melting#
library ("lme4")      # mixed effect model - with plotting #
#
library ("vegan")     # metaMDS#
# functions#
# ==========#
# Loaded from helper script:#
source("/Users/paulczechowski/Documents/CU_combined/Github/500_00_functions.R")#
#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data read-in#
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#' Bolting in ob 20.05.2019 - Importing mandans HON data#
mat_trips_hon<-read.csv("/Users/paulczechowski/Box Sync/CU_NIS-WRAPS/190208_hon_data/hon_matrix.csv", sep=",", row.names=1)#
mat_trips_hon <- as.matrix(mat_trips_hon)#
#
#' ## Predictors 2 of 2: Environmental Distances#
#'#
#' This data is available for many ports (more ports then shipping routes)#
load("/Users/paulczechowski/Documents/CU_combined/Zenodo/R_Objects/500_30_shape_matrices__output__mat_env_dist_full.Rdata")#
#
# checking - see debugging notes: some port numbers in row-/colnames are not unique#
#          - see debugging notes: row- and colnames are undefined, bu seemingly consitent with above#
#             so likley less problematic#
mat_env_dist_full[35:50, 35:50]#
#'      #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#
# this path should match the parameter combination of the Euler script (which isn't used anymore) <-- continue here#
resp_path <- "/Users/paulczechowski/Documents/CU_combined/Zenodo/Qiime/135_18S_eDNA_samples_100_Eukaryotes_core_metrics/unweighted_unifrac_distance_matrix/distance-matrix.tsv"#
resp_mat <- read.table(file = resp_path, sep = '\t', header = TRUE)#
#
# checking import and format#
resp_mat[35:50, 35:50]#
resp_mat[01:10, 01:10]#
class(resp_mat)#
#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' # Data formatting #
#'#
#' ## Predictors 1 of 2: HON Voyages#
#'#
#
colnames(mat_trips_hon) <- c("ZB", "GH", "AW", "RT", "BT", "SW",#
                             "HT", "NO", "WL", "OK", "MI", "LB",#
                             "HN", "VN", "BA", "AD", "RC", "NA",#
                             "CB")#
rownames(mat_trips_hon) <- c("AD", "AW", "BT", "BA", "CB", "GH",#
                             "HN", "HT", "LB", "MI", "NA", "NO",#
                             "OK", "PL", "PM", "RC", "RT", "SW",#
                             "VN", "WL", "ZB")#
#
# order names alphabetically - for sanity reasons#
mat_trips_hon <- mat_trips_hon[,order(colnames(mat_trips_hon))]#
mat_trips_hon <- mat_trips_hon[order(rownames(mat_trips_hon)), ]#
# need symmetrical matrix, discarding some values#
mat_trips_hon <- mat_trips_hon[colnames(mat_trips_hon), ]#
dim(mat_trips_hon)#
#
mat_trips <- mat_trips_hon#
#
# setting port numbers#
# colnames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")#
# rownames(mat_trips_hon) <- c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "238", "193", "4777", "830", "1165", "311", "7975", "1675")#
# #
# #
# mat_trips <- mat_trips_hon [c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675"), #
#                             c("2503", "1165", "1165", "3110", "2907", "854",#
#                               "2503", "2331", "7597", "4899",  "576", "2729",#
#                               "2141", "3108", "3381", "7598",  "238",  "193",#
#                               "4777",  "830",  "311", "4538", "7975", "1675")]#
#
# Keep lower triangle#
# mat_trips[lower.tri(mat_trips, diag = FALSE)] <- NA#
# #
# predictors - copy names - make automatic !! #
# colnames(mat_trips) <- colnames(r_mat_clpsd)#
# rownames(mat_trips) <- rownames(r_mat_clpsd)#
# #
# ' Finished matrix - Trips. Needs to be used to filter all other matrices#
# ' (Other predictors and responses) to the same non-`NA` before analysis.#
# mat_trips#
#
#' #
#' ## Responses 1 of 3: Unifrac distance matrix as produced by Qiime 2#
#'#
#' Need to be done before the predictors: Matrix fields need to be averaged (09-Apr-2019: using median)#
#' across replicates. The resulting ports descriptors are then used to shape#
#' predictor data. **NOT** Inverting Unifrac distances to closeness in order to match #
#' `(1 / src_heap$ROUT$EDST)`, which also is a measure of closeness.#
#
# substitute dots `.` in column headers with minus `-` to match row names#
colnames(resp_mat) <- gsub( '\\.' , '-', colnames(resp_mat))#
#
# set data frame row-names correctly #
rownames(resp_mat) <- resp_mat$X; resp_mat$X <- NULL#
#
# check data frame row and column formatting - better to have them equal #
any(colnames(resp_mat) == rownames(resp_mat))#
#
# Create empty receiving matrix from data frame ...#
r_mat_clpsd <- get_collapsed_responses_matrix(resp_mat)#
#
# ... and fill empty receiving matrix. #
r_mat_clpsd <- fill_collapsed_responses_matrix_full(r_mat_clpsd, resp_mat)#
#
# for possible subsetting #
colnames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
rownames(r_mat_clpsd) # "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI" "AW" "BA" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN" "GH" "WL" "ZB"#
r_mat_clpsd <- r_mat_clpsd[colnames(mat_trips_hon), ]#
r_mat_clpsd <- r_mat_clpsd[, colnames(mat_trips_hon)]#
#
write.csv(r_mat_clpsd, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/510_85_hon_model_1__output__collapsed_matrix_full.csv")#
#
#'#
#' ## Predictors 2 of 2: Environmental distances#
#'#
# quick and dirty - manual lookup#
#   use order  of response matrix (!!!)#
#   here "PH","SP","AD","CH", "BT", "HN", "HT", "LB", "MI"#
#   improve (!!!) this. Manual lookup via:#
#   `open /Users/paulczechowski/Dropbox/NSF\ NIS-WRAPS\ Data/raw\ data\ for\ Mandana/PlacesFile_updated_Aug2017.xlsx -a "Microsoft Excel"`#
#
mat_env_dist <- mat_env_dist_full[c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675"), #
                                  c("3110", "576", "2729", "854", "2141", "4538", "2503", "2331", "7597", "4899", "3108", "3381", "7598", "4777", "830", "1165", "311", "7975", "1675")] #
#
# mat_env_dist[lower.tri(mat_env_dist, diag = FALSE)] <- NA#
#
# predictors - copy names - make automatic !! #
colnames(mat_env_dist) <- colnames(r_mat_clpsd)#
rownames(mat_env_dist) <- rownames(r_mat_clpsd)#
#' Finished matrix -#
#' to match predictors influenced by available voyages before analysis.#
mat_env_dist#
#
#'#
#' <!-- #################################################################### -->#
#'#
#'#
#' <!-- #################################################################### -->#
#'#
#' ## Getting Dataframes for modelling #
#'#
#
# create named list with objects#
mat_list <- list (r_mat_clpsd, mat_env_dist, mat_trips) #
#
mat_list <- setNames(mat_list, c("resp_unifrac", "pred_env", "pred_trips"))#
#
# Are all matrix dimesions are the same?#
var(c(sapply (mat_list, dim))) == 0#
#
# Are all matrices symmetrical and have the same rownames and column names#
all(sapply (mat_list, rownames) == sapply (mat_list, colnames))#
#
# melt data frames for joining #
df_list <- lapply (mat_list, function(x) data.frame(x)  %>%#
                             rownames_to_column("PORT") %>%#
                             melt(., id.vars = "PORT"))#
#
# join dataframes and name columns - "NA" (Nanaimo) becomes "NA." to not be R's "NA"#
#  also one column isn't a factor variable - correcting this#
model_data_raw <- df_list %>% reduce(inner_join, by = c("PORT", "variable")) %>%#
                          setNames(c("PORT", "DEST", toupper(names(mat_list))))#
class(model_data_raw)#
#
levels(model_data_raw$DEST)[ which (levels(model_data_raw$DEST) == "NA.")] <- "NX"#
model_data_raw$PORT <- as.factor(model_data_raw$PORT)#
levels(model_data_raw$PORT)[ which (levels(model_data_raw$PORT) == "NA")] <- "NX"#
#
# check this table carefully for consistent column names#
model_data_raw#
#
# remove incomplete cases - only ignoring lower half of matrix, otherwise remove #
#  column selector#
model_data_raw[model_data_raw == 0] <- NA#
model_data <- model_data_raw %>% filter(complete.cases(.))#
class(model_data)#
model_data#
#
# add ecoregion as per:  # <-- continue here#
#   @Costello, M. J., Tsai, P., Wong, P. S., Cheung, A. K. L., Basher, Z. #
#   and Chaudhary, C. (2017) “Marine biogeographic realms and species endemicity,” #
#   Nature Communications. Springer US, 8(1), p. 1057. doi: 10.1038/s41467-017-01121-2..#
#   write as function !!!!!!!!#
#   here using REALMS, there are 30 Realms listed in the paper (Fig 1, Fig2b)#
#   09-April-2019 ("BA" and "HN" missing after subsampling)#
#   here "PH" "SW" "SY" "AD" "CH" "BT" "HN" "HT" "LB" "MI"#
#        "AW" "CB" "NA" "NO" "OK" "PL" "PM" "RC" "RT" "VN"#
model_data <- model_data %>% add_column("ECO_PORT" = NA)#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("HN", "PH"), "17", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("SY", "SW"), "13", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AD"), "26", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("PM", "BA"), "24", model_data$"ECO_PORT"))#
model_data <- model_data %>% mutate (ECO_PORT = ifelse( .$"PORT"  %in% c("AW", "RT", "GH", "ZB"), "3", model_data$"ECO_PORT"))#
#
model_data <- model_data %>% add_column("ECO_DEST" = NA)#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("HN", "PH"), "17", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("SY", "SW"), "13", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AD"), "26", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("CH","BT","MI", "HT", "NO", "WL"), "11", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("LB", "CB", "OK", "PL", "RC", "VN", "NX"), "7", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("PM", "BA"), "24", model_data$"ECO_DEST"))#
model_data <- model_data %>% mutate (ECO_DEST = ifelse( .$"DEST"  %in% c("AW", "RT",  "GH", "ZB"), "3", model_data$"ECO_DEST"))#
#
model_data <- model_data %>% add_column("ECO_DIFF" = NA)#
model_data <- model_data %>% mutate (ECO_DIFF = ifelse(ECO_PORT == ECO_DEST , FALSE, TRUE))#
#
write.csv(model_data, file = "/Users/paulczechowski/Documents/CU_combined/Zenodo/Results/505_80_mixed_effect_model__output__model_input.csv")#
#
# Checking response and predictor variable distributions#
#
## Responses#
ggplot(model_data,aes (x=RESP_UNIFRAC))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are tiny#
aggregate(model_data$RESP_UNIFRAC~model_data$ECO_DIFF, FUN=mean)#
#
ggplot(model_data,aes (x=PRED_ENV))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# differences are a bit better#
aggregate(model_data$PRED_ENV~model_data$ECO_DIFF, FUN=mean)#
#
## Pedictors#
ggplot(model_data,aes (x=PRED_TRIPS))+ #
  geom_density()+#
  facet_grid(~ECO_DIFF)+#
  theme_bw()#
#
# more trips within ecoregions in data - not surprising#
aggregate(model_data$PRED_TRIPS~model_data$ECO_DIFF, FUN=mean)#
#'#
#' <!-- #################################################################### -->#
#'#
#' <!-- #################################################################### -->#
#'#
# model_data <- model_data %>%  mutate_if(is.numeric, scale(.,scale = FALSE))#
pairs(RESP_UNIFRAC ~ PRED_ENV * PRED_TRIPS, data=model_data, main="Simple Scatterplot Matrix")#
#
#' # Select variables for modelling and build models #
model_data#
#
model_data$PORT <- as.factor(model_data$PORT)#
model_data$DEST <- as.factor(model_data$DEST)#
model_data$ECO_DIFF <- as.factor(model_data$ECO_DIFF)#
#
# reordering columns for model#
vars <- model_data %>% select(RESP_UNIFRAC, PORT, DEST, ECO_DIFF, PRED_ENV, PRED_TRIPS)#
#
#' ## Full Model and checking #
vars_model_full <- lmer(RESP_UNIFRAC ~ PRED_ENV + PRED_TRIPS + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
vars_model_full#
summary(vars_model_full)#
coef(vars_model_full) #intercept for each level#
#
# For linear models, you can also plot standardized beta coefficients,#
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html#
# using type = "std" or type = "std2". These two options differ in the way how#
# coefficients are standardized. type = "std2" plots standardized beta values,#
# however, standardization follows Gelman’s (2008) suggestion, #
# rescaling the estimates by dividing them by two standard deviations#
# instead of just one. (Use, type = std)#
#
library("sjPlot")#
plot_model(vars_model_full, show.values = TRUE, value.offset = .3,#
   type = "std", #
   title = "HON Approach: Response of UNIFRAC values to Predictors (in SD)")#
#
#' Residuals#
plot(vars_model_full)#
#
## check normality of the residuals#
qqnorm(residuals(vars_model_full))#
#
## plotting random effects - trial after https://stackoverflow.com/questions/13847936/in-r-plotting-random-effects-from-lmer-lme4-package-using-qqmath-or-dotplot#
# qqplot of the random effects with their variances#
# "The last line of code produces a really nice plot of each intercept with the error around each estimate."#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$PORT#
qqmath(ranef(vars_model_full, condVar = TRUE), strip = FALSE)$DEST#
#' ### Leverage of Observations#
#
## model is not influenced by one or a small set of observations ?#
ggplot(data.frame(lev=hatvalues(vars_model_full),pearson=residuals(vars_model_full, type="pearson")),#
      aes(x=lev,y=pearson)) + geom_point() + theme_bw()#
#
#' ## Null Model and checking #
#
vars_model_null <- lmer(RESP_UNIFRAC ~ PRED_ENV + ECO_DIFF + (1 | PORT) + (1 | DEST), data=vars, REML=FALSE)#
#
#' ### Model Summary#
summary(vars_model_null)#
#
#' ## Model Significance#
anova(vars_model_null, vars_model_full)#
#
#' <!-- #################################################################### -->#
#'#
#' # Session info#
#'#
#' The code and output in this document were tested and generated in the#
#' following computing environment:#
#+ echo=FALSE#
sessionInfo()#
#
#' # References
conda update conda
update.packages()
update.packages(ask = FALSE)
if (!requireNamespace("BiocManager", quietly = TRUE))#
    install.packages("BiocManager")#
BiocManager::install()
require("tidyverse")
install.packages("tidyverse")
q()
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
mdat$Combo1 <- paste(mdat$source, mdat$target, sep="-") #Combine two ports into one character string (source-target direction)#
mdat$Combo2 <- paste(mdat$target, mdat$source, sep="-") #Combine ports into one character string (target-source direction)#
head(mdat) #quick eye check of Mandana's data
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
mdat$Combo1 <- paste(mdat$source, mdat$target, sep="-") #Combine two ports into one character string (source-target direction)#
mdat$Combo2 <- paste(mdat$target, mdat$source, sep="-") #Combine ports into one character string (target-source direction)#
head(mdat) #quick eye check of Mandana's data
# Load and format Paul's dataset#
pdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/Results/01_results_euk_asv00_deep_UNIF_model_data_2020-Mar-13-13-16-52_no_ph_with_hon_info.csv", sep=",", header=TRUE) # read in Paul's input data emailed 2020-03-12)#
pdat$Combo <-paste(pdat$PORT, pdat$DEST, sep="-") #Combine two ports into one character string (PORT-DEST)#
head(pdat)# quick eye check of Paul's data
# Merge Madana's into Paul by summing up to two directed risk estimates for every port pair into one undirected estimate#
output <- cbind(pdat,data.frame(matrix(nrow=dim(pdat)[1], ncol=13, 0)))  # create and output data frame - start with Paul's data then add Mandana's variables all set to 0#
colnames(output)[9:21] <- colnames(mdat)[3:15] # name Mandana's risk columns#
head(output) # quick eye check of the empty output data
for (i in 1:dim(output)[1]) # loop through each of Pauls Combo to find and sum Mandana's directed risk estimates#
{#
  match1 <- match(output$Combo[i], mdat$Combo1); match1[is.na(match1)] <- 0 # search Mandana's Combo1 for a match, if no match then 0#
  match2 <- match(output$Combo[i], mdat$Combo2); match2[is.na(match2)] <- 0 # search Mandana's Combo2 for a match, if no match then 0#
  sums <- colSums(mdat[c(match1, match2), 3:15]) # sum the two matched rows in Mandana's data#
  output[i, 9:21]= sums # add summed risks to the output dataset#
  rm(sums) # clear the sums variable (so it doesn't carry over)#
} #
#
head(output) # quick eye check of the filled output data - raw version#
output <- output[!(as.character(output$PORT)== as.character(output$DEST)),] # remove port pairs between the same ports#
head(output) # quick eye check of the filled output data - pairs with identical ports removed#
output$voyage_freq # quick eye check of the voyage frequency counts
output
#################################################################
### Check & Merge Mandana and Paul's data#
### E.K. 2020-03-18 - modified: P.C. 2020-03-27#
################################################################
#
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages#
#
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
# to make compatible - rename column headers#
#  carried over from `/Users/paul/Documents/CU_combined/Github/500_81_extend_model_tables.R`
names(mdat)
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages#
#
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
# to make compatible - rename column headers#
#  carried over from `/Users/paul/Documents/CU_combined/Github/500_81_extend_model_tables.R`
names(mdat)
# old names#
# ---------#
#      "source"                  "target"                  "voyage_freq"             "Ballast FON noEco"       "Ballast HON noEco"      #
#      "Ballast FON sameEco"     "Ballast HON sameEco"     "Ballast FON noEco_noEnv" "Ballast HON noEco_noEnv" "Fouling FON noEco"      #
#      "Fouling HON noEco"       "Fouling FON sameEco"     "Fouling HON sameEco"     "Fouling FON noEco_noEnv" "Fouling HON noEco_noEnv"#
# new names #
# ---------#
#      "PORT",                   "DEST",                   "VOY_FREQ",               "B_FON_NOECO",            "B_HON_NOECO",#
#      "B_FON_SMECO",            "B_HON_SMECO",            "B_FON_NOECO_NOENV",      "B_HON_NOECO_NOENV",      "F_FON_NOECO", #
#      "F_HON_NOECO",            "F_FON_SMECO",            "F_HON_SMECO",            "F_FON_NOECO_NOENV",      "F_HON_NOECO_NOENV"#
#
names(mdat) <- c("PORT", "DEST", "VOY_FREQ", "B_FON_NOECO", "B_HON_NOECO", "B_FON_SMECO",#
                          "B_HON_SMECO", "B_FON_NOECO_NOENV", "B_HON_NOECO_NOENV",  "F_FON_NOECO", #
                          "F_HON_NOECO", "F_FON_SMECO", "F_HON_SMECO", "F_FON_NOECO_NOENV", #
                          "F_HON_NOECO_NOENV")
names(mdat)
mdat$Combo1 <- paste(mdat$PORT, mdat$DEST, sep="-") #Combine two ports into one character string (source-target direction)#
mdat$Combo2 <- paste(mdat$DEST, mdat$PORT, sep="-") #Combine ports into one character string (target-source direction)#
head(mdat) #quick eye check of Mandana's data
pdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/Results/01_results_euk_asv00_deep_UNIF_model_data_2020-Mar-13-13-16-52_no_ph_with_hon_info.csv", sep=",", header=TRUE) # read in Paul's input data emailed 2020-03-12)#
pdat$Combo <-paste(pdat$PORT, pdat$DEST, sep="-") #Combine two ports into one character string (PORT-DEST)#
head(pdat)# quick eye check of Paul's data
pdat
cbind(pdat,data.frame(matrix(nrow=dim(pdat)[1], ncol=13, 0)))
colnames(output)[9:21]
output <- cbind(pdat,data.frame(matrix(nrow=dim(pdat)[1], ncol=13, 0)))
output
colnames(mdat)[3:15]
colnames(output)[9:21] <- colnames(mdat)[3:15] # name Mandana's risk columns#
head(output) # quick eye check of the empty output data
colnames(mdat)[3:15]
colnames(output)[9:21]
colnames(output)[9:21] <- colnames(mdat)[3:15]
colnames(output)[9:21]
head(output) # quick eye check of the empty output data
colnames(output)[9:21]
colnames(output)
#################################################################
### Check & Merge Mandana and Paul's data#
### E.K. 2020-03-18 - modified: P.C. 2020-03-27#
################################################################
#
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages#
#
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
#
# to make compatible - rename column headers#
#  carried over from `/Users/paul/Documents/CU_combined/Github/500_81_extend_model_tables.R`#
#
names(mdat)#
#
# old names#
# ---------#
#      "source"                  "target"                  "voyage_freq"             "Ballast FON noEco"       "Ballast HON noEco"      #
#      "Ballast FON sameEco"     "Ballast HON sameEco"     "Ballast FON noEco_noEnv" "Ballast HON noEco_noEnv" "Fouling FON noEco"      #
#      "Fouling HON noEco"       "Fouling FON sameEco"     "Fouling HON sameEco"     "Fouling FON noEco_noEnv" "Fouling HON noEco_noEnv"#
# new names #
# ---------#
#      "PORT",                   "DEST",                   "VOY_FREQ",               "B_FON_NOECO",            "B_HON_NOECO",#
#      "B_FON_SMECO",            "B_HON_SMECO",            "B_FON_NOECO_NOENV",      "B_HON_NOECO_NOENV",      "F_FON_NOECO", #
#      "F_HON_NOECO",            "F_FON_SMECO",            "F_HON_SMECO",            "F_FON_NOECO_NOENV",      "F_HON_NOECO_NOENV"#
#
names(mdat) <- c("PORT", "DEST", "VOY_FREQ", "B_FON_NOECO", "B_HON_NOECO", "B_FON_SMECO",#
                          "B_HON_SMECO", "B_FON_NOECO_NOENV", "B_HON_NOECO_NOENV",  "F_FON_NOECO", #
                          "F_HON_NOECO", "F_FON_SMECO", "F_HON_SMECO", "F_FON_NOECO_NOENV", #
                          "F_HON_NOECO_NOENV")#
mdat$Combo1 <- paste(mdat$PORT, mdat$DEST, sep="-") #Combine two ports into one character string (source-target direction)#
mdat$Combo2 <- paste(mdat$DEST, mdat$PORT, sep="-") #Combine ports into one character string (target-source direction)#
head(mdat) #quick eye check of Mandana's data#
#
# Load and format Paul's dataset#
pdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/Results/01_results_euk_asv00_deep_UNIF_model_data_2020-Mar-13-13-16-52_no_ph_with_hon_info.csv", sep=",", header=TRUE) # read in Paul's input data emailed 2020-03-12)#
pdat$Combo <-paste(pdat$PORT, pdat$DEST, sep="-") #Combine two ports into one character string (PORT-DEST)#
head(pdat)# quick eye check of Paul's data#
#
# Merge Madana's into Paul by summing up to two directed risk estimates for every port pair into one undirected estimate#
#   create output data frame#
output <- cbind(pdat,data.frame(matrix(nrow=dim(pdat)[1], ncol=13, 0)))   #
colnames(output)[9:21] <- colnames(mdat)[3:15] # name Mandana's risk columns#
head(output) # quick eye check of the empty output data
colnames(output)
colnames(output)[9:21]
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages#
#
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
#
# to make compatible - rename column headers#
#  carried over from `/Users/paul/Documents/CU_combined/Github/500_81_extend_model_tables.R`#
#
names(mdat)
#################################################################
### Check & Merge Mandana and Paul's data#
### E.K. 2020-03-18 - modified: P.C. 2020-03-27#
################################################################
#
# Housekeeping#
rm(list=ls(all=TRUE)) ## clear memory#
setwd("/Users/paul/Documents/CU_combined/Github") # set working directory, or (possibly) omit#
packages<- c() # name required packages in this vector#
lapply(packages, require, character.only=T) # load required packages#
#
# Load and format Mandana's dataset#
mdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/HON_predictors/200227_All_links_1997_2018_updated.csv", sep=",", header=TRUE) # read in Mandana's data#
#
# to make compatible - rename column headers#
#  carried over from `/Users/paul/Documents/CU_combined/Github/500_81_extend_model_tables.R`#
#
names(mdat)#
#
# old names#
# ---------#
#      "source"                  "target"                  "voyage_freq"             "Ballast FON noEco"       "Ballast HON noEco"      #
#      "Ballast FON sameEco"     "Ballast HON sameEco"     "Ballast FON noEco_noEnv" "Ballast HON noEco_noEnv" "Fouling FON noEco"      #
#      "Fouling HON noEco"       "Fouling FON sameEco"     "Fouling HON sameEco"     "Fouling FON noEco_noEnv" "Fouling HON noEco_noEnv"#
# new names #
# ---------#
#      "PORT",                   "DEST",                   "VOY_FREQ",               "B_FON_NOECO",            "B_HON_NOECO",#
#      "B_FON_SMECO",            "B_HON_SMECO",            "B_FON_NOECO_NOENV",      "B_HON_NOECO_NOENV",      "F_FON_NOECO", #
#      "F_HON_NOECO",            "F_FON_SMECO",            "F_HON_SMECO",            "F_FON_NOECO_NOENV",      "F_HON_NOECO_NOENV"#
#
names(mdat) <- c("PORT", "DEST", "VOY_FREQ", "B_FON_NOECO", "B_HON_NOECO", "B_FON_SMECO",#
                          "B_HON_SMECO", "B_FON_NOECO_NOENV", "B_HON_NOECO_NOENV",  "F_FON_NOECO", #
                          "F_HON_NOECO", "F_FON_SMECO", "F_HON_SMECO", "F_FON_NOECO_NOENV", #
                          "F_HON_NOECO_NOENV")#
mdat$Combo1 <- paste(mdat$PORT, mdat$DEST, sep="-") #Combine two ports into one character string (source-target direction)#
mdat$Combo2 <- paste(mdat$DEST, mdat$PORT, sep="-") #Combine ports into one character string (target-source direction)#
head(mdat) #quick eye check of Mandana's data#
#
# Load and format Paul's dataset#
pdat <- read.table("/Users/paul/Documents/CU_combined/Zenodo/Results/01_results_euk_asv00_deep_UNIF_model_data_2020-Mar-13-13-16-52_no_ph_with_hon_info.csv", sep=",", header=TRUE) # read in Paul's input data emailed 2020-03-12)#
pdat$Combo <-paste(pdat$PORT, pdat$DEST, sep="-") #Combine two ports into one character string (PORT-DEST)#
head(pdat)# quick eye check of Paul's data#
#
# Merge Madana's into Paul by summing up to two directed risk estimates for every port pair into one undirected estimate#
#   create output data frame#
output <- cbind(pdat,data.frame(matrix(nrow=dim(pdat)[1], ncol=13, 0)))   #
colnames(output)[9:21] <- colnames(mdat)[3:15] # name Mandana's risk columns#
head(output) # quick eye check of the empty output data#
#
for (i in 1:dim(output)[1]) # loop through each of Pauls Combo to find and sum Mandana's directed risk estimates#
{#
  match1 <- match(output$Combo[i], mdat$Combo1); match1[is.na(match1)] <- 0 # search Mandana's Combo1 for a match, if no match then 0#
  match2 <- match(output$Combo[i], mdat$Combo2); match2[is.na(match2)] <- 0 # search Mandana's Combo2 for a match, if no match then 0#
  sums <- colSums(mdat[c(match1, match2), 3:15]) # sum the two matched rows in Mandana's data#
  output[i, 9:21]= sums # add summed risks to the output dataset#
  rm(sums) # clear the sums variable (so it doesn't carry over)#
} #
#
head(output) # quick eye check of the filled output data - raw version#
output <- output[!(as.character(output$PORT)== as.character(output$DEST)),] # remove port pairs between the same ports#
head(output) # quick eye check of the filled output data - pairs with identical ports removed#
output$voyage_freq # quick eye check of the voyage frequency counts#
write.table(output, "Output.csv", sep=",", row.names=FALSE) #write the output table
